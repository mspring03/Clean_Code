# [03장] 함수

## 목차

1. [작게 만들어라!](#작게-만들어라!)
2. [한 가지만 해라!](#한-가지만-해라!)
3. [함수 당 추상화 수준은 하나로!](#함수-당-추상화-수준은-하나로!)
4. [Switch 문](#Switch-문)
5. [서술적인 이름을 사용하라!](#서술적인-이름을-사용하라!)
6. [함수 인수](#함수-인수)
7. [부수 효과를 일으키지 마라!](#부수-효과를-일으키지-마라!)
8. [명령과 조회를 분리하라!](#명령과-조회를-분리하라!)
9. [오류 코드보다 예외를 사용하라!](#오류-코드보다-예외를-사용하라!)
10. [반복하지 마라!](#반복하지-마라!)
11. [구조적 프로그래밍](#구조적-프로그래밍)
12. [함수를 어떻게 짜죠?](#함수를-어떻게-짜죠?)
13. [결론](#결론)

**[⬆ 위로가기](#목차)**

## 작게 만들어라!

- 함수를 만들때 가장 큰 규칙은 **'작게'**, 그 다음도 **'작게'** 이다.
  - 이 규칙의 근거를 대긴 곤란하지만 저자께서는 오랜 시행착오를 바탕으로 작은 함수가 좋다고 확신하신다.

### 블록과 들여쓰기

- `if`, `else`, `while` 문 등에 들어가는 블록은 한 줄이어야 한다는 의미다.
  - 대개 여기서 함수를 호출한다. 그러면 바깥 함수가 작아질 뿐더러 블록 안에서 호출하는 함수의 이름을 적절히 지으면 코드를 이해하기도 쉬워진다.
- 이 말은 중첩 구조가 생길만큼 함수를 복잡하고 크게 해선 안된다는 뜻이다.
- 함수에 들여쓰기 수준은 1단, 2단을 넘어서면 안된다.
- 그래야 함수는 읽고 이해하기 쉬워진다.

**[⬆ 위로가기](#목차)**

## 한 가지만 해라!

- **함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**
  - 이 문장에서 문제라면 그 '한 가지'가 무엇인지 알기 어려운 점이다.
- 아래 는 한 가지만 한다고 볼수 있을까? 세 가지를 한다고 주장할 수도 있다.

1. 페이지가 테스트 페이지인지 판단한다.
2. 그렇다면 설정 페이지와 해재 페이지를 넣는다.
3. 페이지를 HTML로 렌더링 한다.

- 위에서 언급하는 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다.
- 함수는 간단한 TO 문단으로 기술할 수 있다.

`TO RenderPageWithSetupsAndTeardowns`, 페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링한다.

- 함수 이름 내에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
- 조금 위 3단계를 더이상 줄이는건 볼가능하다. if 문을 `includeSetupsAndTeardownsIfTestPate`라는 함수로 만든다면 똑같은 내용을 다르게 표현할 뿐 추상화 수준은 바뀌지 않는다.
- 함수가 '한 가지'만 하는지 확인 하는 또 다른 방법으로 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

**[⬆ 위로가기](#목차)**

## 함수 당 추상화 수준은 하나로!

- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
  - 추상화 수준은 아주 높고, 중간, 아주 낮고 등 다양한데 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

### _위에서 아래로 코드 읽기: **내려가기** 규칙_

- 코드는 위에서 아래로 **이야기** 처럼 읽혀야 좋다.
- 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
- 즉, 위에서 아래로 내려갈수록 함수 추상화 수준이 한 단계씩 낮아지는데 저자는 이것을 **내려가기** 규칙이라 부른다.

**[⬆ 위로가기](#목차)**

## Switch 문

- switch 문은 작게 만들기 어렵다.
- 일반적으로 저자는 switch 문을 단 한번 참아준다고 한다.
  - 다형적 객체를 생성하는 코드 안에서다.
  - 저자도 이 규칙을 위반한 경험이 여러 번 있다.

**[⬆ 위로가기](#목차)**

## 서술적인 이름을 사용하라!

- 함수가 하는 일을 좀 더 잘 표현하면 훨씬 좋은 이름이다.
- 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 주석보다 좋다.
- 이름을 붙일 때는 일관성이 있어야 한다.
  - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
    `includeSetupAndTeardownPges, includeSetupPages, includeSuiteSetupPage, includeSetupPage` 등이 좋은 예이다.
- 문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.

**[⬆ 위로가기](#목차)**

## 함수 인수

- 함수에서 이상적인 인수 개수는 0개(무항) 이다.
- 4개 이상(다항)은 특별한 이유가 필요하다. 이유가 있어도 사용하면 안된다.
- 테스트 관점에서 보면 인수는 더 어렵다. 인수가 없을수록 간단하다.

### 플래그 인수

- 플래그 인수는 추하다.
- 함수로 `boolean` 값을 넘기는 관례는 끔직하다.
  - 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 나타내는 셈이니까
- `render(true) render(boolean isSuite)` 라는 코드는 헷갈리기 쉽상이다.
  - `renderForSuite()` 와 `renderForSingleTest()` 라는 함수로 나눠야 마땅하다.

**[⬆ 위로가기](#목차)**

## 부수 효과를 일으키지 마라!

- 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 **남몰래** 다른 것도 하니까.

```typescript
class UserValidator {
  private cryptoGrapher: Cryptographer;

  public checkPassword(userName: string, password: string): boolean {
    const user: User = UserGateway.findByName(userName);
    if (user !== User.NULL) {
      const codedPhrase: string = user.getPhraseEncodedByPassword();
      const phrase: string = cryptographer.decrypt(codedPhrase, password);
      if (phrase === 'Valid Password') {
        Session.initialze();
        return true;
      }
    }
    return false;
  }
}
```

- 여기서 함수가 일으키는 부수 효과는 `Session.initialize()` 호출이다.
- `checkPassword` 함수는 말 그대로 암호를 확인한다. 이름만 봐서는 세션을 초기화한다는 사실이 드러나지 않는다.
- 세션을 초기화해도 되는 상황ㅇ만 호출이 가능하다. 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다. `checkPasswordAndInitializeSession`이라는 이름이 훨씬 좋다.
  - 물론 함수가 '한 가지'만 한다는 규칙을 위반하지만.

### _출력 인수_

- 일반적으로 우리는 인수를 함수 **입력** 으로 해석한다.

`appendFooter(s);`

- 이 함수는 무언가에 s를 바닥글로 첨부할까? 아니면 s에 바닥글을 첨부할까? 인수 s는 입력일까 출력일까?

```typescript
appendFooter(report: StringBuffer): void
```

- 인수 s가 출력 인수라는 사실은 분명하지만 함수 선언부를 찾아보고 나서야 알았다.
- 출력 인수로 사용하라고 설계한 변수가 바로 this이다. 다시 말해, `appendFooter`는 다음과 같이 호출하는 방식이 좋다.

`report.appendFooter()`

- 일반적으로 출력 인수는 피해야 한다.
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

**[⬆ 위로가기](#목차)**

## 명령과 조회를 분리하라!

- 함수는 무언가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

`set(attribute: string, value: string): boolean`

- 이 함수는 이름이 attribute인 속성을 찾아 value로 설정한 후 성공하면 true를 반환하고 실패하면 false를 반환한다. 그래서 다음과 같이 괴상한 코드가 나온다.

`if (set('username', 'woochanleee')) { ... }`

- "set"이라는 단어가 동사인지 형용사인지 분간하기 어렵다.
- 함수를 구현한 개발자는 "set"을 동사로 의도했다. 하지만 **if 문에 넣고 보면 형용사로 느껴진다.**
- 그래서 "username" 속성이 woochanleee로 설정되어 있다면... 으로 읽히게 된다.
- set이라는 함수 이름을 `setAndCheckIfExists` 라고 바꾸는 방법도 있지만 if문에 넣고 보면 여전히 어색하다.
- 진짜 해결책은 명력과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다.

```typescript
if (attributeExists('username')) {
  setAttribute('username', 'woochanleee');
  ...
}
```

**[⬆ 위로가기](#목차)**

## 오류 코드보다 예외를 사용하라!

- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

`if (deletePage(page) === E_OK)`

- 위 코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다.
- 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제가 생긴다.
- 반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

### _Try/Catch 블록 뽑아내기_

- try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.
- try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
- 오류 처리도 한 가지 작업이다.
- 함수에 키워드 try가 있다면 함수는 try문으로 시작해 catch/finally 문으로 끝나야 한다.

**[⬆ 위로가기](#목차)**

## 반복하지 마라!

**[⬆ 위로가기](#목차)**

## 구조적 프로그래밍

**[⬆ 위로가기](#목차)**

## 함수를 어떻게 짜죠?

**[⬆ 위로가기](#목차)**

## 결론
